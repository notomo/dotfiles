snippet final
	final ${1:name} = ${0:value};

snippet var
	var ${1:name} = ${0:value};

snippet import_show
    import '${1:package_name}' show ${0:name};

snippet export
    export '${1:package_name}';

snippet const
options word
	const ${1:expr}

snippet constructor
	${1:Name}() {
		${0:TARGET}
	}

snippet switch
	switch (${1:expr}) {
	case ${2:expr}:
		${3:case}
		break;
	default:
		${0:TARGET}
	}

snippet generator_sync
	Iterable<${1:T}> ${2:name}() sync* {
	    ${0:TARGET}
	}

snippet yield
    yield ${0:expr};

snippet case
	case ${1:expr}:
		${0:TARGET}
		break;

snippet import
	import '${0:name}';

snippet as
options word
	as ${0:name}

snippet main
	void main() {
		${0:TARGET}
	}

snippet closure
options word
	(${1:arg}) {
		${0:TARGET}
	}

snippet print
	print(${0:expr});

snippet for
	for (final ${1:e} in ${2:list}) {
		${0:TARGET}
	}

snippet for_inc
	for (var i = ${1:0}; i < ${2:max}; i++) {
		${0:TARGET}
	}

snippet ifonly
	if (${1:condition}) {
		${0:TARGET}
	}

snippet else
	else {
		${0:TARGET}
	}

snippet return
	return ${0:expr};

snippet method
	${1:void} ${2:name}(${3:arg}) {
		${0:TARGET}
	}

snippet class
	class ${1:Name} {
		${0:TARGET}
	}

snippet extension
	extension ${1:Name} on ${2:TargetName} {
		${0:TARGET}
	}

snippet enum
	enum ${1:Name} {
		${0:TARGET}
	}

snippet try_on
	try {
		${0:TARGET}
	} on ${1:Error} {
	}

snippet list_type
alias List
options word
	List<${0:dynamic}>

snippet map_type
alias Map
options word
	Map<${1:dynamic}, ${1:dynamic}>

## flutter

snippet initState
	@override
	void initState() {
		super.initState();
		${0:TARGET}
	}

snippet build
	@override
	M.Widget build(M.BuildContext context) {
		${0:TARGET}
	}

snippet dispose
	@override
	void dispose() {
		${0:TARGET}
		super.dispose();
	}

snippet stateful
	class ${1:Name} extends M.StatefulWidget {
		@override
		_$1State createState() => _$1State();
	}

	class _$1State extends M.State<$1> {
		@override
		M.Widget build(M.BuildContext context) {
			${0:TARGET}
		}
	}

snippet stateless
	class ${1:name} extends M.StatelessWidget {
		@override
		M.Widget build(M.BuildContext context) {
			${0:TARGET}
		}
	}
