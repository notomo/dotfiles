snippet public_function
alias pub
abbr public function () {}
	${1:public} function ${3:functionName}(${4}) {
		${5:TARGET}
	}

snippet public_static_function
alias sta
abbr public static function () {}
	${1:public} ${2:static }function ${3:functionName}(${4}) {
		${5:TARGET}
	}

snippet private_function
alias pri
abbr private function () {}
	${1:private} function ${2:functionName}(${3}) {
		${4:TARGET}
	}

snippet protected_function
alias pro
abbr protected function () {}
	${1:protected} function ${2:functionName}(${3}) {
		${4:TARGET}
	}

snippet protected_var
abbr protected $var;
	${1:protected} $${2:var};

snippet const
abbr const
	const ${1:CONST} = '$1';

snippet public_const
abbr public const
	public const ${1:CONST} = ${0};

snippet protected_const
abbr protected const
	protected const ${1:CONST} = ${0};

snippet class_name
abbr Class::class
	${1:ClassName}::class

snippet if_func
alias iffunc
abbr if (func($hoge))
options head
	if (${1}${2:empty}($${3:#:variable})) {
		${0:TARGET}
	}

snippet function
options head
abbr function (){}
	function ${1:FunctionName}(${2}) {
		${3:TARGET}
	}

snippet function_literal_one_line
options word
abbr function (){}
	function (${1}) { ${2:TARGET}; }

snippet function_literal
options word
abbr function (){}
	function (${1}) {
		${2:TARGET}
	}

snippet doc
	/**
	 * ${0}
	 */

snippet testdoc
	/**
	 * @test
	 * @covers ::${1:testName}
	 */

snippet assertSame
options head
	$this->assertSame(${1:$expected}, ${2:$result});

snippet mock
options head
	$${1:mockVar} = M::mock(${2:ClassName}::class);

snippet mmock
	M::mock(${1:ClassName}::class);

snippet shouldReceive
options head
	$${1:mockVar}->shouldReceive(['${2:methodName}' => ${3:returnValue}]);

snippet shouldReceiveMulti
options head
	$${1:mockVar}->shouldReceive([
		'${2:methodName}' => ${3:returnValue},
	]);

snippet mockShouldReceive
options head
	$${1:mockVar} = M::mock(${2:ClassName}::class);
	$$1->shouldReceive(['${3:methodName}' => ${4:returnValue}]);

snippet class
options head
	class ${2:ClassName} {
		${0:TARGET}
	}

snippet abstract_class
options head
	${1:abstract} class ${2:ClassName} {
		${0:TARGET}
	}

snippet interface_class
options head
	${1:interface} class ${2:ClassName} {
		${0:TARGET}
	}


snippet class_extends
options head
	class ${1:ClassName} extends ${2:SuperClassName} {
		${0:TARGET}
	}


snippet def
	${1}defined('${2}')${0}


snippet dowhile
options head
	do {
		${0:TARGET}
	} while (${1:#:condition});

snippet if?
options head
	$${1:#:retVal} = (${2:#:condition}) ? ${3:#:a} : ${4:#:b};

snippet ifelse
options head
	if (${1:#:condition}) {
		${2:TARGET}
	} else {
		${3:#:code...}
	}
	${0}

snippet ifelseif
options head
	if (${1:#:condition}) {
		${2:TARGET}
	} else if (${3:#:condition}) {
		${4:#:code...}
	}
	${0}

snippet ifonly
options head
	if (${1:#:condition}) {
		${0:TARGET}
	}

snippet ifline
options head
	if (${1:#:condition}) ${0:TARGET};

snippet var_dump
options head
	var_dump(${0:TARGET});

snippet exit
options head
	exit;

snippet else
	else {
		${0:TARGET}
	}

snippet elseif
	elseif (${1:#:condition}) {
		${0:TARGET}
	}

snippet for
options head
	for ($${1:i} = ${2:0}; $$1 < ${3}; $$1++) {
		${0:TARGET}
	}

snippet foreach-hashmap
	foreach ($${1:variable} as $${2:key} => $${4:value}) {
		${0:TARGET}
	}

snippet foreach-list
options head
	foreach ($${1:variable} as $${2:x}) {
		${0:TARGET}
	}

snippet construct
options head
	public function __construct(${1}) {
		${0:TARGET}
	}

snippet case
options head
	case ${1:#:variable}:
		${0:#:code...}
		break;

snippet switch
options head
	switch (${1:$variable}) {
		case ${2:$value}:
			${3:#:code...}
			break;
		default:
			${4:#:code...}
			break;
	}

snippet try
options head
	try {
		${1:TARGET}
	} catch (${2:Exception} $e) {
		${3:#:code}
	}

snippet tryf
options head
	try {
		${1:TARGET}
	} catch (${2:Exception} $e) {
		${3:#:code}
	} finally {
		${4:#:code}
	}

snippet thisx
options head
	$this->${1} = $$1;
	${0}

snippet ifset
	${1:nullable} ?? ${2:else}

snippet throw
options head
	throw new ${1}Exception('${2:#:Error Processing Request}');

snippet while
options head
	while (${1}) {
		${0:TARGET}
	}

