snippet public_function
alias pub
abbr public function () {}
	public function ${1:functionName}(${2}) {
		${3:TARGET}
	}

snippet public_static_function
alias sta
abbr public static function () {}
	public static function ${1:functionName}(${2}) {
		${3:TARGET}
	}

snippet private_function
alias pri
abbr private function () {}
	private function ${1:functionName}(${2}) {
		${3:TARGET}
	}

snippet protected_function
alias pro
abbr protected function () {}
	protected function ${1:functionName}(${2}) {
		${3:TARGET}
	}

snippet abstract_function
	abstract ${1:protected} function ${2:functionName}(${3});

snippet protected_var
abbr protected $var;
	protected $${2:var};

snippet const
abbr const
	const ${0:CONST} = '$0';

snippet public_const
abbr public const
	public const ${0:CONST} = '$0';

snippet protected_const
abbr protected const
	protected const ${0:CONST} = '$0';

snippet self_const
abbr self::CONST
options word
	self::${0:CONST}

snippet class_name
abbr Class::class
options word
	${0:ClassName}::class

snippet new
options word
	new ${1:ClassName}(${0})

snippet if_func
alias iffunc
abbr if (func($hoge))
options head
	if (${1}${2:empty}($${3:#:variable})) {
		${0:TARGET}
	}

snippet php
abbr <?php
	<?php

snippet function_only
options head
abbr function (){}
	function ${1:FunctionName}(${2}) {
		${0:TARGET}
	}

snippet anonymous_function_one_line
alias function_one_line
abbr function (){}
	function (${1}) { ${0:TARGET}; }

snippet anonymous_function
alias function func closure
abbr function (){}
	function (${1}) {
		${0:TARGET}
	}

snippet doc
	/**
	 * ${0}
	 */

snippet testdoc
	/**
	 * @test
	 * @covers ::${0:testName}
	 */

snippet inheritDoc
	/**
	 * {@inheritDoc}
	 */

snippet assertSame
alias same
	$this->assertSame(${1:$expected}, ${0:$result});

snippet assertNull
alias null
	$this->assertNull(${0:$result});

snippet assertTrue
	$this->assertTrue(${0:$result});

snippet assertFalse
	$this->assertFalse(${0:$result});

snippet mock
	$${1:mockVar} = M::mock(${0:ClassName}::class);

snippet mmock
options word
	M::mock(${1:ClassName}::class);

snippet shouldReceiveWith
	$${1:mockVar}->shouldReceive('${2:methodName}')->withArgs([${0:$arg}]);

snippet shouldReceive
	$${1:mockVar}->shouldReceive(['${2:methodName}' => ${0:$returnValue}]);

snippet shouldReceiveMulti
	$${1:mockVar}->shouldReceive([
		'${2:methodName}' => ${0:$returnValue},
	]);

snippet mockShouldReceive
	$${1:mockVar} = M::mock(${2:ClassName}::class);
	$$1->shouldReceive(['${3:methodName}' => ${0:$returnValue}]);

snippet class
	class ${2:ClassName} {
		${0:TARGET}
	}

snippet abstract_class
options head
	abstract class ${1:ClassName} {
		${0:TARGET}
	}

snippet interface
options head
	interface ${2:Name} {
		${0:TARGET}
	}

snippet extends
	extends ${0:Name}

snippet implements
	implements ${0:Name}

snippet class_extends
options head
	class ${1:ClassName} extends ${2:SuperClassName} {
		${0:TARGET}
	}

snippet dowhile
options head
	do {
		${0:TARGET}
	} while (${1:#:condition});

snippet if?
options head
	$${1:#:retVal} = (${2:#:condition}) ? ${3:#:a} : ${0:#:b};

snippet ifelse
	if (${1:#:condition}) {
		${2:TARGET}
	} else {
		${0:#:code...}
	}

snippet ifelseif
options head
	if (${1:#:condition}) {
		${2:TARGET}
	} else if (${3:#:condition}) {
		${0:#:code...}
	}

snippet ifonly
	if (${1:condition}) {
		${0:TARGET}
	}

snippet ifline
options head
	if (${1:condition}) ${0:TARGET};

snippet var_dump
options head
	var_dump(${0:TARGET});

snippet exit
options head
	exit;

snippet var_dump_exit
options head
	var_dump(${0:TARGET});
	exit;

snippet else
	else {
		${0:TARGET}
	}

snippet elseif
	elseif (${1:#:condition}) {
		${0:TARGET}
	}

snippet for-index
options head
	for ($${1:i} = ${2:0}; $$1 < ${3}; $$1++) {
		${0:TARGET}
	}

snippet foreach-hashmap
	foreach ($${1:variable} as $${2:key} => $${4:value}) {
		${0:TARGET}
	}

snippet foreach-list
alias for
	foreach ($${1:variable} as $${2:x}) {
		${0:TARGET}
	}

snippet construct
options head
	public function __construct(${1}) {
		${0:TARGET}
	}

snippet case
options head
	case ${1:#:variable}:
		${0:#:code...}
		break;

snippet switch
options head
	switch (${1:$variable}) {
		case ${2:$value}:
			${3:#:code...}
			break;
		default:
			${0:#:code...}
			break;
	}

snippet try
options head
	try {
		${1:TARGET}
	} catch (${2:Exception} $e) {
		${0:#:code}
	}

snippet tryf
options head
	try {
		${1:TARGET}
	} catch (${2:Exception} $e) {
		${3:#:code}
	} finally {
		${0:#:code}
	}

snippet thisx
options head
	$this->${1:TARGET} = $$1;

snippet ifset
options word
	${1:nullable} ?? ${0:else}

snippet throw
options head
	throw new ${1}Exception('${0:Message}');

snippet while
options head
	while (${1}) {
		${0:TARGET}
	}

snippet chain
	->${1:method}()

snippet cchain
	${1:method}()

snippet chain_func
	->${1:method}(function (${2}) {
		${0:TARGET}
	})

snippet cchain_func
	${1:method}(function (${2}) {
		${0:TARGET}
	})

snippet instanceof
options word
	${1:$instance} instanceof ${2:Class}

snippet map
options word
	array_map(function (${2}) { return ${0:TARGET}; }, ${1:array, ...})

snippet return
	return ${0:$value};

snippet return_doc
	@return ${1:type} ${0:description}

snippet param_doc
	@param ${1:type} $${0:name}

snippet throws_doc
	@throws ${0:Name}Exception

snippet dataProvider
	@dataProvider ${0:methodName}

snippet depends
	@depends ${0:methodName}

snippet covers
	@covers ::${0:methodName}

snippet array_key_exists
options word
	array_key_exists($${1:key}, $${1:array})

snippet trait
	trait ${1:Name} {
		${0}
	}

snippet todo
	// TODO: ${0:message}

snippet notice
	// NOTICE: ${0:message}

snippet todo_doc
	@todo ${0:message}

snippet or
options word
	|| ${0:condition}

snippet and
options word
	&& ${0:condition}
