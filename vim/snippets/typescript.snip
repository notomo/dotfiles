include javascript.snip

snippet lambda
options word
	(${1:args}) => {
		${0:TARGET}
	}

snippet class
	class ${1:Name} {
		${0:TARGET}
	}

snippet enum
	enum ${1:Name} {
		${2:value1},
		${0:value2}
	}

snippet get
	get ${1:name}(): ${0:type} {
		return this._$1;
	}

snippet set
	set ${1:name}(${2:value}) {
		this._$1 = $2
	}

snippet let_type
	let ${1:name}: ${0:type};

snippet const_type
	const ${1:name}: ${2:type} = ${0:value}

snippet array_const
	const ${1:array_name}: ${2:type}[] = ${0:value};

snippet array_let
	let ${1:array_name}: ${2:type}[] = ${0:value};

snippet interface
	interface ${1:Name} {
		${0:TARGET}
	}

snippet interface_function
	interface ${1:IName} {
		(${2:name}: ${3:type}): ${0:returnType}
	}

snippet array_interface
	interface ${1:IName} {
		[index: ${2:indexType}]: ${0:type};
	}

snippet variable_interface
alias arg
options word
    ${1:name}: ${0:type}

snippet optional
options word
	${0:name}?

snippet readonly
	readonly ${0:name}

snippet private
options word
	private ${0:name}

snippet public
options word
	public ${0:name}

snippet protected
options word
	protected ${0:name}

snippet method_interface
options word
	${1:name}(${0:args})

snippet constructor_interface
	interface ${1:IName} {
		new (${0:args})
	}

snippet constructor
alias init
	constructor(${1:args}) {
		${0:TARGET}
	}

snippet implements
	implements ${0:Name}

snippet extends
	extends ${0:Name}

snippet public_method
	public ${1:name}(${2:args}) {
		${0:TARGET}
	}

snippet protected_method
	protected ${1:name}(${2:args}) {
		${0:TARGET}
	}

snippet import
	import { ${1:name} } from "${0:file}"

snippet export
	export ${0:name}

snippet thisx
	this.${1:name} = $1;

snippet new
options word
	new ${1:Class}(${0:args});

snippet super
	super();

snippet type_assert
	${1:name} as ${0:type}
