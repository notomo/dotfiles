snippet mod
	mod ${1:name};

snippet mod_inline
	mod ${1:name} {
		${0:TARGET}
	}

snippet let
	let ${1:name} = ${0:expr};

snippet lifetime
	&'${0:a} 

snippet lifetime_param
	<'${0:a}>

snippet mut
	let mut ${1:name} = ${0:expr};

snippet use
	use ${0:name};

snippet eprintln
	eprintln!("{}", ${0:expr});

snippet println
	println!("{}", ${0:expr});

snippet debug
	println!("{:?}", ${0:expr});

snippet format
	format!("${1:format}", ${0:expr})

snippet extern
	extern crate ${0:name};

snippet fn
	fn ${1:name}(${2:args}) ->${3:type} {
		${0:TARGET}
	}

snippet fn_signature
	fn ${1:name}(${2:args}) -> ${0:type};

snippet main
	fn main() {
		${0:TARGET}
	}

snippet loop
	loop {
		${0:TARGET}
	}

snippet while
	while ${1:condition} {
		${0:TARGET}
	}

snippet for
	for ${1:var} in ${2:iterator} {
		${0:TARGET}
	}

snippet match
	match ${1:expr} {
		${0:TARGET}
	}

snippet pattern
    ${1:name} => ${0:result},

snippet struct
	struct ${1:Name} {
		${0:TARGET}
	}

snippet impl
	impl ${1:Name} {
		${0:TARGET}
	}

snippet impl_for
	impl ${1:TraitName} for ${2:StructName} {
		${0:TARGET}
	}

snippet trait
	trait ${1:Name} {
		${0:TARGET}
	}

snippet pub
	pub ${0:value}

snippet enum
	enum ${1:Name} {
		${0:TARGET}
	}

snippet result
alias Result
	Result<${1:Ok}, ${0:Err}>

snippet option
alias Option
	Option<${0:Type}>

snippet ok
alias Ok
	Ok(${0:expr})

snippet some
alias Some
	Some(${0:expr})

snippet err
alias Err
	Err(${0:expr})

snippet ok_pattern
	Ok(${1:value}) => ${0:expr}

snippet err_pattern
	Err(${1:err}) => ${0:expr}

snippet some_pattern
	Some(${1:value}) => ${0:expr}

snippet none_pattern
	None => ${0:expr}

snippet unwrap
	unwrap()

snippet iflet
	if let ${1:pattern} = ${2:expr} {
		${0:TARGET}
	}

snippet ifonly
alias if
	if ${1:expr} {
		${0:TARGET}
	}

snippet else
	else {
		${0:TARGET}
	}

snippet derive
    #[derive(${1:Debug})]

snippet vec
	vec![${0:values}]

snippet to_string
	to_string()$0

snippet tests
	#[cfg(test)]
	mod tests {
		${0:TARGET}
	}

snippet test
    #[test]
	fn ${1:name}() {
		${0:TARGET}
	}

snippet assert_eq
	assert_eq!(${1:want}, ${0:got});

snippet Vec
	Vec<${0:type}>

snippet closure
options word
	|${1:x}| ${0}

snippet const
	const ${1:name}: ${2:type} = ${0:value}

snippet type_hint
	::<${0:type}>

snippet method
	fn ${1:name}(&self) ->${3:type} {
		${0:TARGET}
	}

snippet new
	pub fn new(${1:args}) -> Self {
		${0:TARGET}
	}

snippet return
	return ${0:value};

snippet type
	type ${1:name} = ${0:type}

snippet doc
	/// ${0:TARGET}
